# Web_in_codeit
웹 프론트엔드를 공부하면서 실습했던 과제 및 프로젝트들을 담고 있습니다. 또한, 웹 프론트엔드를 공부하면서 알아두면 유용 할 것 같은 부분들은 README에 정리하며 기록하고 있습니다.

> ### 학습 기간
- 21.08.25 ~ 27 HTML/CSS 기초 (완)
- 21.08.28 ~ HTML/CSS 핵심 (학습중)

> ### 목차

## HTML

- Tag

  - [Semantic Tags(or Semantic Markup)](#Semantic-Tags)
    - [Semantic Tags의 중요성 3대장](#Semantic-Tags가-중요한-이유-3가지)
  - [웹 사이트 구조를 이루는 태그들(Box Tag)](#웹-사이트-구조를-이루는-태그들)

## CSS

- 폰트

  - [기본 폰트(default)](#기본-폰트)
  - [폰트 파일 사용법 (@font-face)](#폰트-파일-사용법)
  - [스타일 시트를 활용한 폰트 사용법 (@import)](#특정-스타일-시트에서-또-다른-스타일-시트를-활용한-폰트-사용법)
  - [폰트 참고 사이트](#폰트-참고-사이트)

- CSS display 속성

  - [inline](#inline)
  - [block](#block)
  - [inline-block](#inline-block)

<br />

# `HTML`

## Tag

> ### Semantic Tags
시맨틱(semantic) 태그란? __의미를 전달__ 할 수 있는 태그다. 예를 들어, 시맨틱 태그가 아닌 `<div>`, `<span>` 태그의 경우 그 이름만 들어서는 어떤 내용을 내포하고 있는지 알 수 없다. 그러나 시맨틱 태그인 `<header>`, `<nav>`, `<img>` 태그의 경우 이름만 들어도 `<header>=제목`, `<nav>=내비게이션`, `<img>=그림` 에 대한 내용을 내포 하고 있음을 짐작 할 수 있다. 이와 같이 사람들에게 의미를 전달 할 수 있는 태그를 `시맨틱(semantic) 태그` 라고 한다.

- #### Semantic Tags가 중요한 이유 3가지

  ① 검색 엔진 최적화(search engine optimization, SEO)
    - `SEO(검색 엔진 최적화)`는 __웹사이트가 검색 결과에 더 잘 보이도록 최적화하는 과정__ 이다. 검색 랭크 개선이라고도 한다.
    - `SEO`는 소비자가 자신(회사)의 홈페이지 혹은 콘텐츠를 쉽게 발견할 수 있도록 하는 것이다. `SEO`의 구체적인 방법을 알아보기 전에 기본적으로 필요한 이해는 바로 검색엔진에 관한 것이다. 검색엔진은 인터넷에 산재한 다양한 정보를 미리 수집, 정리한 후 검색 유저가 관련 내용을 검색했을 때 수시로 찾을 수 있도록 해주는 데이터베이스 관리 시스템이다. 대표적으로 ‘네이버’, ‘구글’ 등이 검색 엔진을 가지고 있다. 검색엔진은 ‘크롤링(웹 크롤러로 웹사이트 관련 데이터를 가져오는 과정)’과 ‘인덱싱(크롤링을 통해 얻은 정보를 검색 색인에 저장하는 과정)’을 통해 정보를 카테고리화한다. *(https://www.bloter.net/newsView/blt201805130001 발췌)*
   
  ② 접근성(Accessibility)
    - 사용자의 신체적 특성이나, 지역, 나이, 지식 수준, 기술, 체험과 같은 제한 사항을 고려하여 가능한 많은 사용자가 불편 없이 이용할 수 있도록 제품, 서비스를 만들어 제공하고 이를 평가 할 때 쓰이는 말이다.
    
    - `접근성`이 높다?
      - 제한 사항을 가진 사용자도 불편 없이 사용할 수 있다는 것
      
    - `접근성`이 낮다?
      - 어떠한 제한 때문에 사용하기 불편하거나 사용할 수 없다는 것
     
    - 특히 웹 디자인 분야에서 월드 와이드 웹의 창시자인 팀 버너스 리는 "웹의 힘은 그 광범위함에 있다. 장애에 관계 없이 모든 사람이 접근할 수 있다는 것이 절대적인 장점이다."라고 말했다. 일부 사용자는 시각, 활동, 지각, 청각 등에 장애가 있으며 장애인들이 다른 사람들과 동등하게 웹 탐색을 하고 컴퓨터를 사용하여 여기서 얻을 수 있는 혜택을 고루 누릴 수 있도록 해야 한다. 그러기 위해서는 특수 마우스/키보드/스위치/조이스틱, 음성 인식, 눈동자 인식 등의 장치및 기술을 사용하기도 하며 글자 크기를 크게 하거나 명암 대비를 크게하는 등의 소프트웨어적 방법도 함께 사용한다. *(https://ko.wikipedia.org/wiki/%EC%A0%91%EA%B7%BC%EC%84%B1 발췌)*
    
  ③ For us, 유지보수성(Mainrainability)
    - 장비 또는 시스템이 서비스가 가능한 상태로 작동이 유지되거나 복원될 수 있는 것
    
    - 핵심
      1. 코드는 쉽게 읽여햐 한다.
          - 쉽게 읽히기 위해서 코드는 서술적으로 짜여져 있어야 한다. 예를 들어, 특정 함수에 이름을 정할 때 그 함수의 이름만 봐도 어떤 작업을 하는 지 알 수 있어야 한다는 것 이다. 이처럼 변수, 함수, 모듈, 패키지, 디렉토리 등등 다양한 수준에서의 좋은 이름은 코드를 쉽게 읽도록 도움을 줄 수 있다.
       
      2. 코드는 짧아야 한다.
          - 코드는 짧을 수록 이해하기 쉽다. 짧은 코드의 기준은 라인(line)수가 적은 것 이다. 라인수가 길어지면 하는 일도 많아지도 쉽게 복잡해지기 마련이다. 물론 전체적인 볼륨(Volume)으로 서의 라인수가 아닌, 프로그램을 구성하는 요소들의 라인수를 말하는 것 이다.
        
          - 함수의 라인수를 줄이면 함수 호출 횟수가 증가하여 성능에 악영향을 준다?
            - 그럴 수 있다. 그러나, 함수의 라인수가 늘어난다는 것은 결국 많은 일을 하고 있다는 뜻 이며, 함수가 넘겨받는 인자나 내부의 지역변수의 수가 늘어난다는 뜻 이다. 즉, 변수들이 레지스터를 이용하는 것 보다 스택에 할당될 확률이 놓아서 메모리 접근 시간이 추가적으로 더 필요하며, 전역 변수를 쓴다면 함수의 최적화(메모리 접근도 증가함)도 문제가 될 수 있다. 또한, 함수 자체가 길이가 길기 때문에 코드의 중복이 발생할 가능성이 높고, 재활용이 안 되기에 컴파일 된 실행 파일의 크기를 증가시킬 가능성도 있다.
         
            - 따라서, 함수의 크기를 작게 만드는 것이 크게 만드는 것 보다 유리한 점이 더 많다. 컴파일러도 결국 사람이 만들기에 복잡한 함수를 최적화 하는데는 한계를 가지며, 함수의 호출 오버헤드도 최적화의 중요한 고려 요소이기에 많은 신경을 써서 만들어 졌다. 함수를 크게 만들어서 최적화를 한다고 이야기하는 것은 올바르지 않다. 물론, 루프와 같은 반복문에서 잦은 함수 호출은 문제를 유발 할 수 있다. 그런 경우엔 함수내로 루프를 이동시키면 된다.
      
      3. 코드는 복제된 것이 없어야 한다.
          - 복제된 코드는 모든 오류의 원천과도 같다. 코드 자체의 복제도 있지만, 논리(Program Logic)의 복제도 포함해서 '복제'라고 생각할 수 있다. 복제를 없애는 것은 간단하지만, 생각외로 잘 고치지 않는 것이 일반적이다. 예를 들어, 새로운 모델을 만들기 위해 기존 모델의 코드와 비슷한 코드를 찾아 약간의 수정을 거친 후 사용 하는 것이 대표적이다. 이런 코드는 향후 수정이 어려우며 버그를 유발하는 경향으로 발전할 가능성이 높다. 그러므로 `DRY(Do not Repeat Yourself)` 원칙을 꾸준히 유지해야 할 것이다.
        
          - 복제된 코드를 검증하기 위해서 `CPD(Copy Paste Detecor)`라는 툴을 사용 할 수 있다. 그러나 해당 툴은 권장하지 않는다. 이유는 간단하다. 복제된 코드는 없어야 하기 때문이다.
        
      4. 하나의 기능만 충실히 구현해야 한다.
          - 기능을 많이 구현하려는 욕심은 언제나 복잡한 코드로 이어진다. 다양한 기능으로 이루어진 코드는 한 가지 기능에 문제가 생기면 나머지 기능들도 제대로 동작하지 않을 가능성이 높다. 또한, 기능간에 연결고리를 만들어 의존성을 높이게 된다. 
        
          - 위 같은 경우 차라리 인터페이스를 분리하고, 공용화 할 수 있는 부분을 뽑아내서 라이브러리 형태로 구축하는 것이 더 좋다.
            - 그 예로 상태의 변경을 일으키는 것(Behaviour, 행동)과 상태를 묻는 것(Query)을 나누는 방법이 있다. 쉽게 말해 특정 상태를 얻어 오는 것과 상태 변경을 발생하는 것을 각각 나누어서 함수로 구현하는 것 이다. 물론, 상태 변경은 한 번에 한 가지만 하는 것이 좋다. 그래야 짧은 코드에 도움이 되며, 파마리터(매개변수)의 갯수나 테스트 케이스도 간단하게 만들어 주기 때문이다. 또한, 성능 향상도 기대 할 수 있다.
          
      5. 테스트에 대한 자동화가 되어있어야 한다.
          - 테스트는 자동화를 높여야 할 부분이다. 사람이 반복적으로 비슷한 일을 해야 할 경우라면 자동화가 가장 빠른 해결책이다. 물론 모든 테스트를 자동화 할 수는 없지만 단위 테스트나 통합 테스트, 시스템 테스트의 일부는 자동화가 가능하다. 자동화의 이점은 과제의 후반으로 갈수록 더 높아지지만, 문제는 테스트 케이스 작성을 쉽게 하기 위해선 위에서 언급한 네 가지 핵심 또한 잘 지켜져야 한다는 것 이다.
          
          - 가독성이 떨어지며 하는 일이 많은 함수는 테스트 하기도 힘들다. 이는 테스트 케이스를 많이 만들어야 한다는 뜻이 되며, 테스트 되지 않는 코드가 많아질 가능성 또한 농후하다. 이는 코드간의 의존성이 높아서 테스트 자체보다는 부가적으로 구축해야 할 것들도 늘어나게 된다. 결국 생산성은 낮아지며 테스트 신뢰도 또한 같이 낮아지게 된다.
        
          - 따라서, 앞에서 열거한 것들을 충실히 지키는 척도로서도 테스트 커버리지(Test Coverage)와 같은 부분을 점검 할 수 있을 것 이다.
            - 테스트 커버리지(Test Coverage)? 테스트 대상의 전체 범위에서 테스트를 수행한 범위를 뜻 한다. 즉, 테스트 대상을 얼마만큼 테스트했나를 정의하는 것 으로, 테스트의 정확성을 판단하는 하나의 척도가 될 수 있다.

<br />

> ### 웹 사이트 구조를 이루는 태그들

웹 사이트를 만들 때, 아래 그림 처럼 `<div>` 태그를 남발하는 경우가 있다. 이러한 방법 보단 정해진 용도에 맞추어 의미 있는 태그를 사용 하는 것이 적절하다.

<img src="https://user-images.githubusercontent.com/75716255/131506537-5b763ff4-0a50-4c74-8c9e-9a6af5a4a066.png" width="50%" height="50%">

<br />

그 방법은 아래와 같다.

<img src="https://user-images.githubusercontent.com/75716255/131507581-2e37a1aa-895c-4b6a-ba41-fd8fe0ce7dd7.png" width="50%" height="50%">

- `<header>`
  - 소개 및 탐색에 도움을 주는 콘텐츠를 나타낸다. 제목, 로고, 검색 폼, 작성자 이름 등의 요소도 포함.
  - 웹 사이트의 브랜드를 나타대는 로고나, 사용자들을 위한 중요한 아이템이 들어있는 경우 사용
 
- `<nav>`
  - 문서의 부분 중 현재 페이지 내, 또는 다른 페이지로의 링크를 보여주는 구획을 나타낸다. 자주 쓰이는 예제는 메뉴, 목차, 색인이다.
  - `<header>` 내부에 여러가지 메뉴들이 모여있다면 `<nav>` 사용

- `<main>`
  - 문서 `<body>`의 주요 콘텐츠를 나타낸다. 주요 콘텐츠 영역은 문서의 핵심 주제나 앱의 핵심 기능에 직접적으로 연결됐거나 확장하는 콘텐츠로 이루어진다.
  - 현재 컨텐츠에서 중요한 내용을 가지고 있다면 `<main>` 사용

- `<article>`
  - 문서, 페이지, 애플리케이션, 또는 사이트 안에서 독립적으로 구분해 배포하거나 재사용할 수 있는 구획을 나타낸다.
  - 게시글 하나 자체를 보여줄 떄 사용. ex) 블로그 게시글
  - 독립적

- `<section>`
  - HTML 문서의 독립적인 구획을 나타내며, 더 적합한 의미를 가진 요소가 없을 때 사용한다.
  - `<main>` 이나 `<article>` 내부에서 연관있는 글들을 묶어줄 때 사용
  
- `<aside>`
  - 문서의 주요 내용과 간접적으로만 연관된 부분을 나타낸다. 주로 사이드바 혹은 콜아웃 박스로 표현한다.
  - 페이지 컨텐츠와 직접적으로 상관이 없으며, 부가적인 내용을 담고 있다면 `<aside>` 사용
 
- `<footer>`
  - 가장 가까운 구획 콘텐츠나 구획 루트의 푸터를 나타낸다. `<footer>`는 일반적으로 구획의 작성자, 저작권 정보, 관련 문서 등의 내용을 담는다.

#### *https://developer.mozilla.org/ko/docs/Web/HTML/Element (참고)*

<br />

# `CSS`

## 폰트

> ### 기본 폰트

```
- serif
  - 'Times New Roman'
  - 궁서체
  
- sans-serif
  - Arial
  - 굴림체
  
- monospace
  - courier
  - 'Courier New'
  
- cursive
  - 'Comic Sans MS'
  - 'Monotype Corsiva'
  
- fantasy
  - Impact
  - Haettenschweiler  
```

<br />

> ### 폰트 파일 사용법

```html (원래 css임, 코드 불키려고 형식만 html로 적어둠)
@font-face {
  src : url("폰트 파일 경로");
  font-family: "폰트 별명";
}

p {
  font-family: "폰트 별명";
}
```

<br />

- #### @font-face, 이것 만은 알아두자!
  - `@font-face`를 사용함으로써 사이트에 추가적인 요청(HTTP)이 들어갈 수도 있음
  - 결과적으로 `'웹 사이트 속도가 느려짐'`
  
  - 따라서 font-weight 또는 font-style 기능을 최대한 적게 사용하고, character set을 가볍게 해서 파일 크기를 줄여야 함
  
- *character set : 정보를 표현하기 위한 글자들의 집합을 정의한 것 (http://hell0-world.com/etc/2020/05/09/ChracterSet.html)*

<br />

> ### 특정 스타일 시트에서 또 다른 스타일 시트를 활용한 폰트 사용법

<br />

```html (원래 css임, 코드 불키려고 형식만 html로 적어둠)
1. @import ".css 파일명"; *문자 형식*
2. @import url(".css 파일명"); *url 형식*
```

<br />
    
 예를 들어, 아래와 같은 `@import 방식` 의 경우 test1.css를 불러온 뒤에 test2.css, test3.css를 차례로 불러온다.
 
  ```html (원래 css임, 코드 불키려고 형식만 html로 적어둠)
  @import "test1.css";  /* 1번째 */
  @import "test2.css";  /* 2번째 */
  @import "test3.css";  /* 3번째 */
  ```
  
<br />

즉, css를 하나하나 순차적(직렬 로딩)으로 불러오기 때문에 css의 양이 얼마 되지 않는다면 크게 상관이 없겠지만, __css의 양이 방대해진다면__ 페이지 로딩속도가 현저히 '느려질 것'이다.

<br />

반면 아래의 `link 방식` 의 경우, test1.css와 test2.css, test3.css가 동시에 로딩(병렬 로딩)하여 불러오기 때문에 페이지 로딩 속도가 @import 방식에 비해 빠르고 효율적이다.

  ```html
  <link rel="stylesheet" href="test1.css">
  <link rel="stylesheet" href="test2.css">
  <link rel="stylesheet" href="test3.css">
  ```

<br />

__결론 : 로딩 문제나 edge 브라우저 버그 문제 등을 고려한다면 link 방식을 사용하자.__

- #### @import & link, 이것 만은 알아두자!
  - Q : `@import 방식`과 `link 방식` 중 어떤 방법이 더 효율적일까? 
  - A : `link 방식(외부 스타일)` 방식이 더 `'효율적'` 이다.
  
  - Why?
    - `@import 방식`의 경우 @import 된 css들을 '직렬' 로딩 방식으로 불러오고,
    - `link 방식`의 경우 '병렬' 로딩 방식으로 css를 불러오기 때문.
 
 <br />

> ### 폰트 참고 사이트
- <https://fonts.google.com/> *영문체*
- https://fonts.google.com/earlyaccess *한글체, Ctrl+F > korean*

<br />

## CSS display 속성
CSS에서 `display` 속성은 웹 페이지 상에서 엘리먼트들이 어떻게 보여지고 다른 엘리먼트와 어떻게 상호 배치되는지를 결정한다.

<br />

> ### inline
`display` 속성이 `inline`으로 지정된 엘리먼트는 전후 줄바꿈 없이 한 줄에 다른 엘리먼트들과 나란히 배치된다. 대표적인 `inline` 엘리먼트로 `<span>`이나 `<a>`, `<em>` 태그 등이 있다. 

<br />

예를 들어, 여러개의 `inline` 엘리먼트들을 아래와 같이 마크업하면 줄바꿈 없이 순서대로 한 줄에 보이게 된다.

```html, css
// HTML 

before
<a>A</a>
<span>SPAN</span>
<em>EM</em>
after

// CSS

span {
  background: yellow;
  width: 200px;
  height: 50px;
  margin: 20px;
  padding: 10px;
}
```

#### 출력 화면
![inline](https://user-images.githubusercontent.com/75716255/131222899-03886dba-d14c-49c3-a316-62834b1b34f3.png)

- #### `inline`, 이것 만은 알아두자!
  - `inline` 엘리먼트는 `width`와 `height` 속성을 지정해도 무시된다.

  - Why?
    - 해당 태그가 마크업하고 있는 컨텐츠의 크기 만큼만 공간을 차지하도록 되어 있기 때문이다.
    - 또한, `margin`과 `padding` 속성은 __좌우 간격__ 만 반영이 되고, __상하 간격__ 은 반영 되지 않는다.

<br />

> ### block
`display` 속성이 `block`으로 지정된 엘리먼트는 전후 줄바꿈이 들어가 다른 엘리먼트들을 다른 줄로 밀어내고 혼자 한 줄을 차지한다. 대표적인 `block` 엘리먼트로, `<div>`이나 `<p>`, `<h1>` 태그 등을 들 수 있다.

<br />

예를 들어, 여러 개의 `block` 엘리먼트들을 아래와 같이 마크업하면 매번 줄바꿈 되어 여러 줄에 보이게 된다.

```html, css
// HTML

before
<h1>H1</h1>
<div>DIV</div>
<p>P</p>
after

// CSS

div {
  background: yellow;
  width: 200px;
  height: 50px;
  margin: 20px;
  padding: 10px;
}
```

#### 출력 화면
![block](https://user-images.githubusercontent.com/75716255/131252531-91c5794b-cb61-4fdb-a310-cf2362949204.png)

- #### `block`, 이것 만은 알아두자!
  - `block` 엘리먼트는 `inline` 엘리먼트와 달리 `width`, `height`, `margin`, `padding` 속성이 모두 반영 된다.

<br />

> ### inline-block
`display` 속성이 `inline-block`으로 지정된 엘리먼트는 기본적으로 `inline` 엘리먼트처럼 전후 줄바꿈 없이 한 줄에 다른 엘리먼트들과 나란히 배치된다. 하지만 `inline` 엘리먼트에서 불가능하던 `width`와 `height` 속성 지정 및 `margin`과 `padding` 속성의 상하 간격 지정이 가능해진다.

<br />

대표적인 `inline-block` 엘리먼트로 `<button>`이나 `<input>`, `<select>` 태그 등을 들 수 있다.

```html, css
// HTML

before
<a>A</a>
<span>SPAN</span>
<em>EM</em>
after

// CSS

span {
  display: inline-block;
  background: yellow;
  width: 200px;
  height: 50px;
  margin: 20px;
  padding: 10px;
}
```

#### 출력 화면
![inline-block](https://user-images.githubusercontent.com/75716255/131252712-11105852-dd95-4cf1-902e-4ec2927b25c5.png)

- #### `inline-block`, 이것 만은 알아두자!
  - `inline-block` 엘리먼트는 위와 같이 명시적으로 헤당 엘리먼트의 스타일을 `display: inline-block`로 지정해줘야 한다.
  - `inline-block`을 이용하면 여러 개의 엘리먼트를 한 줄에 정확히 원하는 너비만큼 배치할 수 있기 때문에 레이아웃에 활용할 수 있다.

<br />

> ### etc
`<span>`로 마크업된 엘리먼트가 `inline` 속성값을 가지고, `<div>`로 마크업된 엘리먼트가 `block` 속성값을 가지는 이유는 소위 `user agent stylesheet`라고 불리는 브라우저의 내장 스타일이 적용(관리자 도구에서 확인 가능) 되어서 그렇다. 이렇게 HTML 태그 별로 기본적으로 적용되어 있는 `display` 속성값은 원하는 값으로 CSS를 이용하서 자유롭게 변경이 가능하다.

<br />

> ### display 참고 사이트
- <https://developer.mozilla.org/en-US/docs/Web/CSS/display>
  - 해당 링크 `Examples`로 가면 각 `display` 마다 적용 되는 예시를 직접 확인 할 수 있다.
